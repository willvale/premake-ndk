--
-- manifest.lua
-- Android manifest (and other build cruft) generator for Premake.
-- Copyright (c) 2014 Will Vale and the Premake project
--

local ndk       = premake.modules.ndk
local project   = premake.project
local config    = premake.config

-- Register the action
newaction {
	trigger     = "ndk-manifest",
	shortname   = "Android NDK manifest",
	description = "Generate manifest and other app build files for Android NDK Build",

	-- ugh; temporary, need to phase this out ASAP
	isnextgen = true,

	-- The capabilities of this action
	valid_kinds     = { "WindowedApp", "StaticLib", "SharedLib" },
	valid_languages = { "C", "C++" },
	valid_tools     = {
		cc     = { "gcc" },
	},

	onsolution = function(sln)
		-- Nothing to do here
	end,

	onproject = function(prj)
		-- Not all projects are valid
		if  not ndk.isValidProject(prj) then
			return
		end

		-- Need to generate one makefile per configuration
		for cfg in project.eachconfig(prj) do
			if cfg.platform ~= ndk.ANDROID then
				error('The only supported platform for NDK builds is "android"')
			end		

			if cfg.kind == premake.WINDOWEDAPP then
				-- Generate the manifest for application projects only

				-- Define closure to pass config
				function generateManifestCallback(prj)
					ndk.generateManifest(prj, cfg)
				end

				-- Generate the manifest
				premake.generate(prj, ndk.getManifestFilename(prj, cfg), generateManifestCallback)

				-- Produce the Java source, if present.
				local java_file = config.findfile(cfg, ndk.JAVA)
				if java_file then
					-- Define closure - we need to tell the project which file to generate.
					function generateJavaCallback(prj)
						ndk.generateJava(prj, cfg, java_file)
					end

					-- Generate Java source
					premake.generate(prj, ndk.getJavaFilename(prj, cfg, java_file), generateJavaCallback)
				end
			end
		end
	end,

	oncleansolution = function(sln)
		-- Nothing to do
	end,

	oncleanproject = function(prj)
		for cfg in project.eachconfig(prj) do
			if prj.kind == premake.WINDOWEDAPP then
				premake.clean.file(prj, ndk.getManifestFilename(prj, cfg))

				local java_file = config.findfile(cfg, ndk.JAVA)
				if java_file then
					premake.clean.file(prj, java_file)
				end
			end
		end
	end
}

-- Manifest goes in project dirctory
function ndk.getManifestFilename(this, cfg)
	return path.join(ndk.getProjectPath(this, cfg), ndk.MANIFEST)
end

-- Source path for Java files. They need to be under a directory tree based on the package name.
function ndk.getJavaPath(this, cfg)
	if not cfg.packagename then
		premake.error( 'No package name specified for application - use "packagename"')
	else
		local forward = string.explode(cfg.packagename, '%.')
		local reverse = {}
		for _,v in ipairs(forward) do
			table.insert(reverse, 1, v)
		end
		return path.join(ndk.getProjectPath(this, cfg), 'src', table.concat(forward, '/'))
	end
end

-- Make name of Java file relative to the Java source path
function ndk.getJavaFilename(this, cfg, file)
	return path.join(ndk.getJavaPath(this, cfg), path.getname(file))
end

-- Determine which version of OpenGL, if any, to link against.
function ndk.getGlesVersion(cfg)
	local links = config.getlinks(cfg, 'system', 'basename')

	-- Specify highest version we linked against
	if table.contains(links, ndk.GLES30) then
		return 0x00030000
	elseif table.contains(links, ndk.GLES20) then
		return 0x00020000
	elseif table.contains(links, ndk.GLES10) then
		return 0x00010000
	end
end

-- Generate manifest file. This describes the application to ant, the Android OS, and the Google Play store.
function ndk.generateManifest(prj, cfg)
	_p('<?xml version="1.0" encoding="utf-8"?>')
	_p('<!-- %s manifest autogenerated by Premake -->', premake.action.current().shortname)
	_x(0, '<manifest xmlns:android="http://schemas.ndk.com/apk/res/android"')
		_x(1, 'package="%s"', cfg.packagename or 'com.example.app')
		_x(1, 'android:versionCode="%d">', cfg.packageversion or 0)
		--_x(1, 'android:versionString="%d">', cfg.packageversion or 0)

	local props
	if cfg.flags.Symbols then
		props = ' android:debuggable="true"'
	end

		_x(1, '<application%s>', props or '')
			_x(2, '<activity>')
				_x(3, '<intent-filter>')
					_p(4, '<action android:name="android.intent.action.MAIN" />')
					_p(4, '<category android:name="android.intent.category.LAUNCHER" />')
				_p(3, '</intent-filter>')
			_p(2, '</activity>')
		_x(1, '</application>')

	if cfg.apilevel then
		_x(1, '<uses-sdk android:minSdkVersion="%d"/>', cfg.apilevel)
	end

	local gles_version = ndk.getGlesVersion(cfg)
	if gles_version then
		_x(1, '<uses-feature android:glEsVersion="0x%08x"/>', gles_version)
	end
	    _x(1, '<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />') 
	_p('</manifest>')
end

-- Generate Java source file for the app package. This is a bit of a hack, and involves copying a Java file from 
-- the project and patching it to contain the correct package path.
function ndk.generateJava(prj, cfg, file)
	-- Read contents of specified file
	local src = path.getabsolute(file, prj.basedir)
	local f = io.open(src, 'r')
	local text = f:read('*all')

	-- Substitute package path
	text = text:gsub('<PREMAKE_PACKAGE>', cfg.packagename)

	-- And write new file
	_p("%s", text)
end

